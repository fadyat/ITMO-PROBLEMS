# tickets-OOP

### Качества хорошей архитектуры

- Повторное использование кода
- Расширяемость

### Базовые принципы проектирования

### Инкапсулируйте то, что меняется

> Определите аспекты программы, класса или метода,
которые меняются чаще всего, и отделите их от того,
что остаётся постоянным
> 

### Программируйте на уровне интерфейсов

> Программируйте на уровне интерфейса, а не на
уровне реализации. Код должен зависеть от абстрак-
ций, а не конкретных классов.
> 

### Предпочитайте композицию наследованию

> Наследование ведёт к сильной связности классов родителей с классами наследников. Вместо наследования можно использовать композицию, вместо того, чтобы объекты сами реализовывали то или иное поведение, они могут делегировать его другим объектам.
> 

### Типы паттернов

### Порождающие паттерны

> Эти паттерны отвечают за удобное и безопасное создание
новых объектов или даже целых семейств объектов.
> 

### Поведенческие паттерны

> Эти паттерны решают задачи эффективного и безопастного взаимодействия между объектами программ
> 

### Структурные паттерны

> Эти паттерны отвечают за построение удобных в поддержке иерархий классов
> 

### SOLID

[https://web-creator.ru/articles/solid_the_single_responsibility_principle](https://web-creator.ru/articles/solid_the_single_responsibility_principle)

## S - Single responsibility principle

> У класса должен быть только один мотив для изменения.
> 

## O - Open/Closed principle

> Расширяйте классы, но не изменяйте их первоначальный код.
> 

## L - Liskov substitution principle

> Подклассы должны дополнять, а не замещать поведение базового класса.
> 

## I - Interface segregation principle

> Клиенты не должны зависеть от методов, которые они
не используют.
> 

## D - Dependency inversion principle

> Классы верхних уровней не должны зависеть от клас-
сов нижних уровней. Оба должны зависеть от абстрак-
ций. Абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.
> 

## База

### 1. В чем идея инкапсуляции? Абстракция, интерфейс и реализация. Средства защиты и доступа.

### Инкапсуляция

Пример: машины сейчас и сто лет назад, по сути одно и тоже, но пользоваться может любая домохозяйка и не нужно знать как устроен паравой двигатель.

**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.

Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, всё то, что не входит в интерфейс, инкапсулируется в классе.

### **Абстракция**

Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерён в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, указатель поворота (ну и, возможно, пепельницу) он будет использовать регулярно.

**Абстрагирование** – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно,

А**бстракция** – это набор всех таких характеристик.

Если бы для моделирования поведения автомобиля приходилось учитывать химический состав краски кузова и удельную теплоёмкость лампочки подсветки номеров, мы никогда бы не узнали, что такое NFS.

### Реализация

**Инкапсуляция поля**

Сделать поле приватным и создать для него методы доступа.

**Инкапсуляция коллекции**

Сделать возвращаемое геттером значение доступным только для чтения и создать методы добавления/удаления элементов этой коллекции.

**Самоинкапсуляция поля**

Проблема: вы используете прямой доступ к приватным полями внутри класса.

Решение: cоздать геттер и сеттер для поля, и пользоваться только ими для доступа к полю.

### 2. В чем идея наследования? Простое, многоуровневое, множественное наследование.

### Наследование

**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. 

Есть аналогичные механизмы: агрегация и композиция. Порой, они намного лучше 

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled.png)

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%201.png)

### 3. В чем идея полиморфизма? Раннее и позднее (динамическое) связывание.

**Полиморфизм** – это возможность обработки разных типов данных (принадлежащих к разным классам, с помощью "одной и той же" метода).

1. *Раннее связывание* – связанное с формированием кода на этапе компиляции. При раннем связывании, программный код формируется на основе известной информации о типе (класс) ссылки. Как правило, это ссылка на базовый класс в иерархии классов.
2. *Позднее связывание* – связанное с формированием кода на этапе выполнения. Если в иерархии классов встречается цепочка виртуальных методов (с помощью слов virtual, override), то компилятор строит так называемое позднее связывание. При позднем связывании вызов метода происходит на основании типа объекта, а не типа ссылки на базовый класс. Позднее связывание используется, если нужно реализовать *полиморфизм*.

### 4. Принцип “информационного эксперта”. В чем идея? С каким принципом SOLID коррелирует?

Шаблон информационный эксперт является базовым и в то же время самым очевидным из девяти. Информационный эксперт описывает основополагающие принципы назначения обязанностей классам и объектам. Согласно описанию, информационным экспертом (объектом наделенным некоторыми обязанностями) является объект, обладающий максимумом информацией, необходимой для выполнения назначенных обязанностей. 

В качестве примера можно рассмотреть подсчет общего количества груза и его стоимости как на определенном рейсе, так и обобщенно для всех рейсов компании.

Коррелирует с принципом single responsobility, потому что он говорит, что класс, который что-то делает, должен быть специализирован на этой задаче, то есть иметь наибольшее кол-во данных по ней.

### 5. В чем заключается смысл принципов низкой связности и высокого зацепления (Low coupling & High cohesion)?

**Слабое зацепление:**

- Степень зацепления — мера неотрывности элемента от других элементов.
- Слабое зацепление является оценочной моделью, которая диктует, как распределить обязанности, которые необходимо поддерживать.
- Слабое зацепление — распределение ответственностей и данных, обеспечивающее взаимную независимость классов. Класс со «слабым» зацеплением:
- - Имеет слабую зависимость от других классов;
- - Не зависит от внешних изменений (изменение в одном классе оказывает слабое влияние на другие классы);
- - Прост для повторного использования.

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%202.png)

**Высокая связность:**

- Класс должен стараться выполнять как можно меньше не специфичных для него задач, и иметь вполне определенную область применения
- Если модуль несет много разноплановой ответственности, он сложнее в поддержке и переиспользовании, а также будет часто меняться

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%203.png)

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%204.png)

### 6. В чем заключается смысл принципа подстановки Лисков? В каком случае и как нарушается принцип в проблеме эллипса-окружности (квадрата-прямоугольника)?

Подклассы должны дополнять, а не замещать поведение базового класса.

**Принцип подстановки Барбары Лисков — The Liskov Substitution Principle или LSP — один из пяти основных принципов объектно-ориентированного программирования и проектирования, сформулированных Робертом Мартином.**

Принцип в формулировке Роберта Мартина декларирует, что функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом. Оригинальное определение Барбары Лисков более формальное и заметно сложнее для восприятия: «В том случае, если q(x) — свойство, верное по отношению к объектам х некого типа T, то свойство q(y) тоже будет верным относительно ряда объектов y, которые относятся к типу S, при этом S — подтип некого типа T».

Следование принципу LSP заключается в том, что при построении иерархий наследования создаваемые наследники должны корректно реализовывать поведение базового типа. То есть если базовый тип реализует определённое поведение, то это поведение должно быть корректно реализовано и для всех его наследников.

LSP перекликается с контрактным программированием, определяя точные, формальные и верифицируемые описания интерфейсов. И интерфейсы, реализумые наследниками, должны соответствовать контракту интерфейсов базового класса.

Наследник класса дополняет, но не заменяет поведение базового класса. То есть в любом месте программы замена базового класса на класс-наследник не должна вызывать проблем. Если по каким-то причинам так не получается, то вероятнее всего имеет место либо некорректная реализация, либо неверно выбранная абстракция для наследования.

Соблюдение принципа подстановки Барбары Лисков позволяет гарантировать, что любой созданный нами подкласс будет без проблем использоваться ранее реализованными модулями, которые работали с надклассом. А это существенно упрощает расширение функциональных возможностей системы.

Но LSP, как и любой другой принцип, не является догмой. И иногда следование этому принципу при построении архитектуры может приводить к более ресурсоёмкой реализации, нежели работа с нарушением этого принципа. Но как и с любыми другими правилами — надо осознавать возможные последствия нарушения.

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%205.png)

### 7. Дайте описание принципам S, I, D из SOLID.

## S - Single responsibility principle

> У класса должен быть только один мотив для изменения.
> 

## I - Interface segregation principle

> Клиенты не должны зависеть от методов, которые они
не используют.
> 

## D - Dependency inversion principle

> Классы верхних уровней не должны зависеть от клас-
сов нижних уровней. Оба должны зависеть от абстрак-
ций. Абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.
> 

### 8. Дайте описание принципам O, L из SOLID.

## O - Open/Closed principle

> Расширяйте классы, но не изменяйте их первоначальный код.
> 

## L - Liskov substitution principle

> Подклассы должны дополнять, а не замещать поведение базового класса.
> 

### 9. Gateway и Mapper. В чём идея? В чём ключевые различия?

**Gateway** - Объект, который инкапсулирует доступ к внешней системе и ресурсу (Похож на Фасад, Адаптер, Посредник)

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%206.png)

**Когда использовать?**

- Яркий маркер для использования Gateway – наличие неудобного (странного, нелогичного) интерфейса для компонента, который можно расценить как внешний
- Также используется в паттернах более высокого уровня

**Преимущества**

- Систему проще тестировать
- Легко подменять компонент, скрываемый за Gateway

**Mapper** - Объект, который управляет сообщением между независимыми друг от друга объектами. Очень похож на Посредник, но подсистемы не в курсе о существовании Mapper

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%207.png)

**Когда использовать?**

- Спектр применений ограничен, так как сложно сделать так, чтобы компоненты не знали о Mapper и он выполнял свои функции. Mapper может выполнять роль Observer для одного из компонентов
- Используется, когда нужно полностью разделить связанные компоненты
    
    **Разница:** Mapper образует общение между частями внутри программы, в свою очередь Gateway образует общение снаружи (с внешней частью).
    

## Паттерны

### 1. Паттерн одиночка. В чем идея? В чем опасность использования?

**Синглтон** — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%208.png)

синглтон решает сразу две проблемы с нарушением **принципа единой ответственности класса**: 

1. Гарантирует наличие единственного экземпляра класса 
2. Предоставляет глобальную точку доступа

все **реализации** сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный метод, который и будет контролировать жизненный цикл обьекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу.

Наивный синглтон небезопасен в многопоточке.

- *Пример*
    
    ```csharp
    using System;
    
    namespace RefactoringGuru.DesignPatterns.Singleton.Conceptual.NonThreadSafe
    {
        // Класс Одиночка предоставляет метод `GetInstance`, который ведёт себя как
        // альтернативный конструктор и позволяет клиентам получать один и тот же
        // экземпляр класса при каждом вызове.
    
        // Синглтон всегда должен быть «запечатанным» классом, чтобы предотвратить
        // наследование через внешние классы, а также через вложенные классы.
        public sealed class Singleton
        {
            // Конструктор Одиночки всегда должен быть скрытым, чтобы предотвратить
            // создание объекта через оператор new.
            private Singleton() { }
    
            // Объект одиночки храниться в статичном поле класса. Существует
            // несколько способов инициализировать это поле, и все они имеют разные
            // достоинства и недостатки. В этом примере мы рассмотрим простейший из
            // них, недостатком которого является полная неспособность правильно
            // работать в многопоточной среде.
            private static Singleton _instance;
    
            // Это статический метод, управляющий доступом к экземпляру одиночки.
            // При первом запуске, он создаёт экземпляр одиночки и помещает его в
            // статическое поле. При последующих запусках, он возвращает клиенту
            // объект, хранящийся в статическом поле.
            public static Singleton GetInstance()
            {
                if (_instance == null)
                {
                    _instance = new Singleton();
                }
                return _instance;
            }
    
            // Наконец, любой одиночка должен содержать некоторую бизнес-логику,
            // которая может быть выполнена на его экземпляре.
            public static void someBusinessLogic()
            {
                // ...
            }
        }
    
        class Program
        {
            static void Main(string[] args)
            {
                // Клиентский код.
                Singleton s1 = Singleton.GetInstance();
                Singleton s2 = Singleton.GetInstance();
    
                if (s1 == s2)
                {
                    Console.WriteLine("Singleton works, both variables contain the same instance.");
                }
                else
                {
                    Console.WriteLine("Singleton failed, variables contain different instances.");
                }
            }
        }
    }
    ```
    

Существует и многопоточная версия singleton, ее отличие в том, что мы синхронизируем потоки при создании обьекта

- *Пример*
    
    ```csharp
    using System;
    using System.Threading;
    
    namespace Singleton
    {
        // Эта реализация Одиночки называется "блокировка с двойной проверкой"
        // (double check lock). Она безопасна в многопоточной среде, а также
        // позволяет отложенную инициализацию объекта Одиночки.
        class Singleton
        {
            private Singleton() { }
    
            private static Singleton _instance;
    
            // У нас теперь есть объект-блокировка для синхронизации потоков во
            // время первого доступа к Одиночке.
            private static readonly object _lock = new object();
    
            public static Singleton GetInstance(string value)
            {
                // Это условие нужно для того, чтобы не стопорить потоки блокировкой
                // после того как объект-одиночка уже создан.
                if (_instance == null)
                {
                    // Теперь представьте, что программа была только-только
                    // запущена. Объекта-одиночки ещё никто не создавал, поэтому
                    // несколько потоков вполне могли одновременно пройти через
                    // предыдущее условие и достигнуть блокировки. Самый быстрый
                    // поток поставит блокировку и двинется внутрь секции, пока
                    // другие будут здесь его ожидать.
                    lock (_lock)
                    {
                        // Первый поток достигает этого условия и проходит внутрь,
                        // создавая объект-одиночку. Как только этот поток покинет
                        // секцию и освободит блокировку, следующий поток может
                        // снова установить блокировку и зайти внутрь. Однако теперь
                        // экземпляр одиночки уже будет создан и поток не сможет
                        // пройти через это условие, а значит новый объект не будет
                        // создан.
                        if (_instance == null)
                        {
                            _instance = new Singleton();
                            _instance.Value = value;
                        }
                    }
                }
                return _instance;
            }
    
            // Мы используем это поле, чтобы доказать, что наш Одиночка
            // действительно работает.
            public string Value { get; set; }
        }
    
        class Program
        {
            static void Main(string[] args)
            {
                // Клиентский код.
                
                Console.WriteLine(
                    "{0}\n{1}\n\n{2}\n",
                    "If you see the same value, then singleton was reused (yay!)",
                    "If you see different values, then 2 singletons were created (booo!!)",
                    "RESULT:"
                );
                
                Thread process1 = new Thread(() =>
                {
                    TestSingleton("FOO");
                });
                Thread process2 = new Thread(() =>
                {
                    TestSingleton("BAR");
                });
                
                process1.Start();
                process2.Start();
                
                process1.Join();
                process2.Join();
            }
            
            public static void TestSingleton(string value)
            {
                Singleton singleton = Singleton.GetInstance(value);
                Console.WriteLine(singleton.Value);
            } 
        }
    }
    ```
    

### 2. Паттерн состояние. В чем идея? Какое ключевое отличие от паттерна стратегия?

**Состояние** — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

**Реализация**: У контекста есть публичные методы для вызова реквестов а так же приватное поле-абстрактный класс общего состояния с ссылкой на контекст и с объявлениями всех методов которые надо реализовать, конкретные состояния их реализуют. 

нужен когда (состояний много, они часто меняются / в коде класса много условных операторов / и так используется таблица состояний ) 

**+**проще контекст, код раскидан по состояниям, 

**-**если состояний мало то нафиг надо 

- *Пример*
    
    ```csharp
    class Program
    {
        static void Main()
        {
            Context context = new Context(new StateA());
            context.Request(); // Переход в состояние StateB
            context.Request();  // Переход в состояние StateA
        }
    }
    abstract class State
    {
        public abstract void Handle(Context context);
    }
    class StateA : State
    {
        public override void Handle(Context context)
        {
            context.State = new StateB();
        }
    }
    class StateB : State
    {
        public override void Handle(Context context)
        { 
            context.State = new StateA();
        }
    }
     
    class Context
    {
        public State State { get; set; }
        public Context(State state)
        {
            this.State = state;
        }
        public void Request()
        {
            this.State.Handle(this);
        }
    }
    ```
    

В отличие от стратегии, объекты связаны, состояния могут сами переходить друг в друга, это нужно когда поведение объекта должно зависеть от его состояния и может изменяться динамически во время выполнения

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%209.png)

### 3. Паттерн стратегия. В чем идея? Какое ключевое отличие от паттерна состояние?

**Стратегия** — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

**Реализация**: Общий интерфейс, который выполняет методы по-разному в зависимости от стратегии выбранной клиентом в контексте 

Нужен когда (разные вариации одного алгоритма / много похожих классов отл. Одним алгоритмом / вариации алгоритмов сделаны через ifы / спрятать детали реализации) 

+реализует O 

-больше классов, клиент должен знать разницу

 В отличие от состояния, объекты не знают друг о друге и не связаны

### 4. Паттерн легковес. В чем идея? Когда его следует применять?

**Легковес** — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

**Реализация**: отдельные классы для общего состояния, уникального состояния, легковеса и контекста. В легковесе содержится только приватное общее состояние, сеттеров нет. Когда нужен объект общее состояние которого уже существует - используется оно, иначе создается новое.

- *Пример*
    
    ```csharp
    class FlyweightFactory
    {
        Hashtable flyweights = new Hashtable();
        public FlyweightFactory()
        {
            flyweights.Add("X", new ConcreteFlyweight());
            flyweights.Add("Y", new ConcreteFlyweight());
            flyweights.Add("Z", new ConcreteFlyweight());
        }
        public Flyweight GetFlyweight(string key)
        {
            if (!flyweights.ContainsKey(key))
                flyweights.Add(key, new ConcreteFlyweight());
            return flyweights[key] as Flyweight;
        }
    }
     
    abstract class Flyweight
    {
        public abstract void Operation(int extrinsicState);
    }
     
    class ConcreteFlyweight : Flyweight
    {
        int intrinsicState;
        public override void Operation(int extrinsicState)
        {
        }
    }
     
    class UnsharedConcreteFlyweight : Flyweight
    {
        int allState;
        public override void Operation(int extrinsicState)
        {
            allState = extrinsicState;
        }
    }
     
    class Client
    {
        void Main()
        {
            int extrinsicstate = 22;
     
            FlyweightFactory f = new FlyweightFactory();
     
            Flyweight fx = f.GetFlyweight("X");
            fx.Operation(--extrinsicstate);
     
            Flyweight fy = f.GetFlyweight("Y");
            fy.Operation(--extrinsicstate);
     
            Flyweight fd = f.GetFlyweight("D");
            fd.Operation(--extrinsicstate);
     
            UnsharedConcreteFlyweight uf = new UnsharedConcreteFlyweight();
     
            uf.Operation(--extrinsicstate);
        }
    }
    ```
    

Нужен когда (куча одинаковых объектов, которые тратят много памяти)

+меньше оперативки

-больше нагрузки на ЦП и куча доп классов

### 5. Паттерн заместитель. В чем идея? Какие виды (типы) заместителей бывают? Для решения каких задач применяются?

**Заместитель** — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то *до* или *после* передачи вызова оригиналу.

**Реализация:** Имеется общий интерфейс для сервиса и заместителя, с которым работает клиент. В заместителе есть приватная ссылка на сервис.

**Виртуальный прокси** нужен для отложенной инициализации, чтобы подгружать тяжелые объекты только когда нужны

**Защищающий прокси** нужен чтобы проводить проверку перед выдачей доступа 

**Удаленный прокси** когда нужный сервис находится на удаленном сервере и мы запускаем его локально 

**Логирующий прокси** когда нужно сохранять историю обращений 

**Кэширующий прокси** когда нужно управлять жизненным циклом запросов клиентов 

+контроль, незаметность для клиента, отложенная инициализация 

-увеличивает время отклика, дополнительные классы

### 6. Паттерн команда. В чем идея? Как его можно комбинировать с партнёром снимок?

**Команда** — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

**Реализация**: Создаем интерфейс команды с методом выполнения и наследуем от него конкретные команды, простые команды работают сами (и хранят для этого какие-то поля), сложные делегируют выполнение получателям (и хранят приватно ссылки на получателей и данные о контексте), получатели содержат методы чтобы что-то делать. У класса отправителя в приватных полях один или несколько интерфейсов команд, сеттеры для них, и функция выполнения. 

Нужен когда (превратить операцию в объект / ставить операции в очередь / отменять операции (хранить историю))

-много доп классов 

+позволяет отменять и откладывать операции, убирает прямую зависимость между вызовом и выполнением, собирать сложные команды их простых, реализует О 

Работает вместе со снимком для отмены (снимок хранит точное состояние объекта до операции, команда выполнять действия над объектом)

### 7. Паттерн снимок. В чем идея? Как его можно комбинировать с партнёром команда?

**Снимок** — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.

Реализация: Класс создателя содержит в себе приватное поле состояния и какую-то логику, а так же методы save и load работающие с интерфейсом снимка. Интерфейс снимка имеет геттеры для некоторых значений состояния, но само состояние не раскрывает. У конкретного снимка поля для хранения значений и состояния и реализация инфраструктуры. Опекун хранит в себе ссылку на создателя и лист снимков, а так же различные методы (бэкап, отмена, показ истории) 

Нужен когда (нужно запомнить состояние объекта и всех его полей, не ломая инкапсуляцию) 

+не ломает инкапсуляцию, упрощает исхордный объект 

-может съесть много памяти, может быть сложно огрнаичить доступ

Работает вместе с командой для отмены (снимок хранит точное состояние объекта до операции, команда выполнять действия над объектом)

### 8. Паттерн фабричный метод. В чем идея? В чем разница между паттернам фабричный метод и шаблонный метод?

**Фабричный метод** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Реализация: Имеется абстрактный класс создатель, в нем абстрактный фабричный метод возвращающий интерфейс продукта и какая-то операция. От интерфейса продукта наследуются конкретные продукты, реализующие операцию, от создателя конкретные создатели, реализующие метод. 

Нужен когда (заранее неизвестны типы и зависимости объектов /  дать возможность расширения / использовать созданные объекты не порождая новые) 

+нет привязки к конкретным классам, упрощает масштабирование, выделяет производство в одно место, реализует О 

-большие параллельные иерархии классов 

Разница в том, что паттерн порождающий, и нужен когда надо создавать объекты или использовать уже существующие

### 9 Паттерн шаблонный метод. В чем идея? В чем разница между паттернам фабричный метод и шаблонный метод?

**Шаблонный метод** — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

Реализация: Имеется абстрактный класс, в нём определён сам шаблонный метод, возможно определены некоторые из его шагов. Конкретные классы должны реализовать все нереализованные операции.

 Нужен когда (подклассы расширяют базовый алгоритм, не изменяя / несколько классов делают почти одно и то же) 

+Облегчают реюз 

-ограничены существующим скелетом метода, можно нарушить L, сложно поддерживать с увеличением кол-ва шагов 

Разница в том что используется когда у нас много шагов, часть из которых может исполняться по-разному

### 10. Паттерн посетитель. В чем идея? Какие требования предъявляются к классам, которые можно посещать?

**Посетитель** — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.

Реализация: У нас есть интерфейс компонентов и интерфейс посетителей. **!**В каждом конкретном компоненте надо прописать метод, который принимает визитора и говорит этому визитору посетить этот конкретный компонент (иначе надо либо миллион свитч кейсов, либо смерть от неправильного полиморфизма, получается **дабл диспатч**)**!**. От интерфейса визиторов наследуем конкретных визиторов, каждый должен реализовать методы посещения каждого конкретного объекта.

Нужен когда (выполнить операцию над всеми элементами структуры / не хочется засорять классы / новое поведение нужно только части иерархии) 

+проще добавлять новые операции 

-не работает если иерархия часто изменяется, может нарушить инкапсуляцию

### 11. Паттерн декоратор. В чем идея? Когда следует применять?

**Декоратор** — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

**Реализация:** Абстрактный класс декоратора наследуется от компонента, его метод оверрайдит операцию компонента, всю работу декоратор делегирует обратно обернутому компоненту. Конкретные декораторы уже реализуют изменения в операции компонента.

Нужен когда (нужно расширять объекты незаметно для кода который их использует / когда наследование не катит)

+гибче наследования, добавляет обязанности на ходу, можно добавлять и комбинировать множество мелких объектов

-сложно конфигурировать классы с кучей декораторов, появляется миллион маленьких классов

### 12. Паттерн адаптер. В чем идея? Когда следует применять?

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

 **Реализация** Есть интерфейс клиента, адаптируемый класс и адаптер, наследуемый от клиентского интерфейса. Адаптер содержит приватную ссылку на адаптируемый и методы для выполнения запроса клиента, использующие методы адаптируемого.

 Нужен когда (интерфейс стороннего класса не соответствует приложению / объединить подклассы в которых не хватает общей функциональности / два класса с несовместимыми  интерфейсами) 

+объединяет и скрывает преобразования 

-доп классы

### 13. Паттерн мост. В чём идея? Когда следует применять?

**Мост** — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

**Реализация** Есть класс абстракции (можно расширить подклассами) с приватной (протектед) ссылкой на реализацию и интерфейс реализации с подклассами конкретных реализаций.

Нужен когда (разделить монолитный класс на абстракцию и реализацию (вместо миллиона классов) / класс расширяется в двух плоскостях / Изменять реализацию во время выполнения программы) 

+скрывает детали реализации, реализует О 

-усложняет код программы из-за введения доп классов

### 14. Паттерн цепочка обязанностей. В чем идея? Когда следует применять?

**Цепочка обязанностей** — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

**Реализация:** Интерфейс обработчика объявляет метод построения цепочки и метод обработки. Абстрактный класс от него может реализовать поведение по умолчанию. Конкретные обработчики уже реализуют сет следующего и обработку запроса.

Нужен когда:

- Важно чтобы обработчики выполнялись строго последовательно
- Набор объектов, способных обработать запрос, должен задаваться динамически

+Уменьшает зависимость между клиентом и обработчиками, реализует O и S

-запрос может остаться необработанным

### 15. Паттерн фасад. В чем идея? Когда следует применять?

**Фасад** — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

Смысл в том, что мы имеем нагруженную систему классов или используем библиотеку и нам не удобно и не нужно держать весь код снаружи, поэтому мы создаем фасад над этим кодом, чтобы его скрыть из-за бесполезности этого кода для пользователя.

**Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.**

**Когда вы хотите разложить подсистему на отдельные слои.** 

### 16. Паттерн посредник. В чем идея? Когда следует применять?

**Посредник** — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

Смысл в том, что мы имеем интерфейс, который при происхождении какого-то ивента, вызывает метод с источником и типом ивента, чтобы вынести логику взаимодействия разных объектов в отдельный класс для абстрагирования от лишних связей между ними.

Когда применять:

- Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.
- Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.
- Когда вам приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах.

### 17. Паттерн наблюдатель. В чем идея? Когда следует применять?

**Наблюдатель** — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

Имеются интерфейсы издателя и наблюдателя. В издателе имеются методы добавления, убирания и оповещения наблюдателей, подклассы их реализуют. Наблюдатели содержат в себе метод получения оповещения (обновления), конкретные подклассы реализуют их по-разному.
Нужен когда:

- После изменения состояния одного объекта нужно что-то сделать в других, но каких - наперед неизвестно
- Одни объекты должны наблюдать за другими, но только в определенных случаях

+Издатели не зависят от конкретных классов подписчиков и наоборот, список подписчиков динамический, реализуется O
-Оповещение подписчиков в случайном порядке

## Многослойная архитектура

### 1. Какие слои присутствуют в классической 3х уровневой архитектуре. Дайте краткое описание и назначение каждого слоя.

Существуют 3 слоя DAL, BLL и Presentation. 

DAL отвечает за работу с базой данных: поиск, запись и тд. 

BLL отвечает за работу самой логики программы(чем именно занимается программа)

Presentation отвечает за работу с клиентом и обработкой его запросов.

### 2. Какие обязанности берет на себя слой DAL? С какими слоями и как он связан?

DAL отвечает за работу с базой данных: поиск, запись и тд. ~~Может в себя включать DTO модели и отдельные репозитории для работы с бд~~. Выкачивая данные из базы по запросу от слоя BLL, передает ему данные для дальнейшей работы логики программы

### 3. Какие обязанности берет на себя слой BLL? С какими слоями и как он связан?

BLL отвечает за работу самой логики программы(чем именно занимается программа). Может включать в себя модели бизнес логики и сервисы для работы с ними. Получая запрос от Presentation, он вытаскивает данные из DLL и совершает с ними подразумевающиеся действия.

### 4. Какие обязанности берет на себя слой Presentation? С какими слоями и как он связан?

Presentation отвечает за работу с клиентом и обработкой его запросов. Может включать себя контроллеры работающие с соответствующими сервисами. Получая запрос от пользователя передает его BLL, и получает, что именно ему было нужно, возвращая обратно пользователю.

### 5. Паттерны слоя DAL. Перечислить, дать краткое описание каждому, указать ключевые различия.

**Table Data Gateway**

Класс, который является Gateway для одной таблицы в базе данных. Один экземпляр работает со всеми строками в этой таблице

Инкапсулирует логику преобразования запросов к таблице или представлению этой таблицы в реляционной базе данных в SQL запросы: SELECT, INSERT, UPDATE, DELETE и т.д.

**Row Data Gateway**

Класс, который является Gateway для одной строки в таблице базы данных. Один экземпляр работает с одной строкой в этой таблице

**Active Record**

Класс, который оборачивает строку в таблице базы данных, инкапсулирует доступ к базе данных и содержит бизнес-логику для этих данных

То есть такой объект обладает как данными, так и своим поведением

Очень похож на Row Data Gateway, разница в том, что Active Record содержит код бизнес-логики

**Data Mapper**

Набор классов Mapper, которые перемещают данные между объектами приложения и базой данных, не создавая зависимости между ними

### 6. Паттерны слоя BLL. Перечислить, дать краткое описание каждому, указать ключевые различия

**Transaction Script / Транзакционный сценарий**

Самый простой подход к организации бизнес-логики.

Бизнес-логика разбивается на процедуры, каждая из которых соответствует конкретному запросу, поступающему от слоя представления

**Table Module / Табличный модуль**

Прямое сопоставление класса таблице в базе данных. Экземпляр такого класса (или статический класс) соответствует таблице ЦЕЛИКОМ.

Table Module неплохо работает с Record Set (представление БД в RAM)

- **Domain Model / Модель предметной области**
    
    Выделяются объекты, соответствующие объектам предметной области.
    
    Описываются отношения между такими объектами, соответствующие отношениям между объектами реального мира
    
    Решение технологических вопросов, таких как хранение, безопасность, управление транзакциями, как правило, выносится за пределы слоя бизнес-логики
    
    **Anemic Domain Model / Анемичная модель предметной области -** в объектах предметной области инкапсулируются только данные, поведение же выносится в слой сервисов, расположенный поверх слоя предметной области, лучше работает с active record
    
    - Отклоняется от принципов ООП - т.к. объекты предметной области в случае анемичной доменной модели не имеют поведения, то мы вступаем в противоречие с базовой идеей ООП - иметь данные и методы их обработки в одном месте
    - Проектировать и разрабатывать проще (в начале)
    - Простота автоматического создания объектов на основе схемы хранилища (БД)
    - Лучше переиспользуемость
    
    **Rich Domain Model / Насыщенная модель предметной области** - данные и поведение инкапсулируются внутри объектов предметной области, лучше работает с data mapper 
    
    - Реализует возможности ООП по полной
    - Проектировать и разрабатывать труднее (зато потом жить проще)
    - Довольно часто классы получаются большими
    

### 7. Паттерн Plugin. Описать идею, структуру, привести пример

Связывание классов друг с другом происходит не на этапе компиляции кода, а во время его выполнения. Plugin позволяет делать это централизованно, без необходимости редактирования и сборки исходного кода для изменения конфигурации 

Когда один код выполняется в нескольких средах и требует разной реализации отдельной логики, часто используется паттерн *Выделенный интерфейс*. Большинство разработчиков добиваются этого при помощи использования шаблона фабрики. Представим, что надо генерировать первичный ключ при помощи *Выделенного интерфейса*. Можно использовать для юнит-тестирования простой объект-счётчик, а на реальной системе - последовательность из БД. Фабричный метод скорее всего будет содержать условный переход (if), проверяющий, установлен ли флаг тестирования, и возвращать необходимый генератор ключа.

Как только у вас появится ещё несколько фабрик - начнётся путаница. Создание новой конфигурации, например "запуск юнит-тестов на БД без контроля транзакций" или "запуск в продакшн на DB2 с полной поддержкой транзакций", потребует правок в условиях в большом количестве фабрик, пересборку и переразвёртывание.

Конфигурация не должна быть разбросана по приложению, также как и требовать пересборки и переразвёртывания. Паттерн Plugin решает обе эти проблемы, предоставляя централизованную динамическую конфигурацию.

![Untitled](tickets-OOP%20ccb80cdf99ed43dabd8e0acf31c7b110/Untitled%2010.png)

# Заметки

**Композиция** – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.

**Композиция** это строгая агрегация 

**Агрегация** – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.