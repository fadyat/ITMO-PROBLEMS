# Databases

## Contents
- [Lecture #1](#lecture-1)
- [Lecture #2](#lecture-2)
- [Lecture #3](#lecture-3)
- [Lecture #4](#lecture-4)
- [Lecture #5](#lecture-5)

## Lecture #1

Информация как:

- данные 
- сигнал (не надо знать что именно)
- знания (применение, создание)

Данные - поддающиеся многократные интерпретации, представление информации в **формализованном виде** пригодных для передачи, интерпретации или обработки.

Студент А учится в группе Х  
Преподаватель B читает в группе X

Данные позволяют строить интерпретации.

**I**

| Студент | Группа | Дисциплина | Преподаватель |
| --- 	| --- 	| --- 	| --- |

- Много строчек = \1 * \2 * \3 * \4
- Трудно обеспечимая целостность данных
- Медленный поиск
- Данные неуникальны

**II**

| Студент | Группа | Преподаватель дисциплины 1 | Преподаватель дисциплины N |
| --- 	| --- 	| --- 	| --- |

- Количество памяти меньше прошлой, хотя хранят одинаковую информацию
- Число строк = \1
- Студент - уникален, остальные данные могут повторяться
- Ускорение поиска
- Трудно масштабируемая - необходимо менять структуру


**III**
 
| Student | ID | ID_Group |
| --- | --- | --- |

| Group | ID | ID_Student |
| --- | --- | --- |

| Teacher | ID | ID_Lesson |
| --- | --- | --- |

| ID_G | ID_L |
| --- | --- |

- Уменьшение памяти
- Улучшение ситуации с целостностью данных
- Масштабируемая
- В момент запроса необходима память для поиска `(Join's)`

Базы данных также как и ОС чем-то жертвуют для оптимизации чего-то другого.

- Надежность
- Масштибируемость
- Безопасность
- Производительность?

^ Реаляционная база данных

Файловая система как способ хранения данных - возникают проблемы

- ... (прослушал)
- зависимость от типов данных

Основное противоречие - чтение и запись

Клиент <==> Бизнес-логика <==> Данные

Идея - сделать прослойку между Бизнес-логикой и Данными.

БД / СУБД

СУБД - абстрагирование доступа данных, контроль над целостностью и надежностью.

---

## Lecture #2

### ANSI/SPARC - первый подход как образовать БД
- Внешний уровень (External level)
> Представление базы данных с позиции конечного пользователя
>
> Example: студенты с датой рождения
> 
> Определяется объем и форма представления данных
>
> Для эффективного принятия решений
> 
> Вопрос разделения ролей (разные данные для разных сотрудников)

- Концептуальный уровень (Conceptual level)
> Связь между уровнями
>
> Не думаем о СУБД
>
> Думаем какие данные хотим хранить и в каком формате
>
> Думаем об ограничениях на данные (почта хранится в определенном формате, содержит код компании)
>
> Есть сущности с доступом для определенной роли (например, паспорт пользователя не доступен всем ролям)

- Внутренний уровень (Internal level)
> Физическое представление БД
> 
> Вопросы:
> - как распределить дисковое пространство(не обязательно диски, SSD) для хранения данных и мета-данных
> - не обязатель хранить все данные, можно хранить индексы, деревья данных и множество других вариантов - от этого зависит производительность чтения и записи и их баланс
> - вопросы с безопасностью, каким образом ее обеспечить (шифрование, какое шифрование и т.п.)
> - сжатие данных, попытка избегания дубликации данных (актуально)
> -  Избегания дубликации данных (актуально).<br>Можно попробовать избежать на концептуальном уровне, но так же можно сделать при помощи алгоритмов на внутреннем уровне.

Внешний уровень - UI, UX - все для пользователя (знания, психология, восприятие информации человеком)

Концептуальный уровень - интересно

Немного затрагиваем внутренний уровень

### Уровни моделей данных:
- Модель сущность-связь - ВНЕШ
- Логическая (дата-логическая) модель - К
- Физическая модель - К, ВНУТ

Таблица не самый лучший способ храния данных, не единственный

ER, ERD, ER(A) - entity relationship


### Модель сущность-связь

Сущность - множество экземпляров реальных или абстрактных однотипных предметов предметной области.
- Сильная - независимо от других сущностей
- Слабая - нужна сильная

![](./data/client_1.png)

Атрибуты - свойства сущности:
- Простые
- Составные

or 

- Обязательный
- Необязательный

or

- Однозначные
- Многозначные

Связи:
- 1-1
- 1-Многим
- Многие-многим

Что есть сущность, а что атрибут?

![](./data/client_2.png)

- [Нотация Чена](https://studme.org/77222/informatika/notatsiya_pitera_chena)
- [IDEF1X](https://www.cfin.ru/vernikov/idef/idef1x.shtml)

Данная модель универсальна

### Логическая модель

- Иерархическая
- Сетевая
- Реляционная
- ...

Зависит от того как мы хотим смоделировать данные

Выбираем с помощью чего будем моделировать

### Физическая модель

- Определяем ограничения на именование объектов и способы доступа и обращения к ним.
- Определяем ограничения на типы данных - определяем домены (множество значений для атрибута). <br>
Например, для даты будем использовать DATE и DATETIME.
- Описание индексов и их хранение
- Вопрос разделения на отдельные файлы

--- 

## Lecture #3

### Иерархическая модель данных

Задача:
- Надо уметь хранить деревья

Поле данных - неделимое уникально адресуемая единица хранения данных

Как правило, поле данных - атрибут

Сегмент данных - совокупность полей данных, имеющая уникальную идентификацию

![](./data/hierarchy.jpeg)

Проблемы: 
- Как хранить?

    - Хранить родителя
    - ...
    - Хранить отдельно данные и дерево их отношений с указанием на экземпляр

- Проблема скорости внесения изменений
- Дублирование данных
- Сложности с контролем целостности данных (пример с менеджером, смена фамилии)

Любая реорганизация приводит к трудностям

Почему иерархическая модель?
- Естественный, нативный способ представления данных


### Сетевая модель данных

Решает проблемы дублирования и целостности данных

Начинаем разделять хранение связей от хранения самих данных

![](./data/network.jpeg)

 Храним:
 - Поле данных
 - Агрегат (объединение множества полей)
 - Связь

Множество связей и множество узлов

При модификации надо обходить граф - дорого

> Сетевая > Иерархическая, но всеравно плохо

У каждого агрегата выделяем ключ

Тогда храним ключ и дополнительные сведения

Проблемы:
- Поиск
- Храним пары ключей - возможны ошибки с хранением 

### Реляционная модель данных

Отношения = агрегаты

Отношение - совокупность полей данных (множество кортежей)

![](./data/relational.svg)

Храним связи отдельно в таких же отношениях

Реляционная модель - модель хранения отношений

- one-many: id
- many-many: новое отношение для связи ключей

Удобна в:
- Предпосылки к избеганию дубликации данных
- При грамотной работе (нормализации) позволяет гарантировать целостность данных
- Удалось построить относительно эффективные операции над данными

Проблема:
- поле - неделимый элемент данных (не имеет внутренней структуры)

### Постреляционная модель данных

- Снимаем запрет на целостность поля данных - поле данных может само по себе являться агрегатом


После 2000-х: проблема больших данных для реляционной и постреляционной моделей

Будем считать, что для нас скорость вычислений важнее памяти


| Продажи | | |
| --- | --- | --- |
| Продукт | Месяц | Объем |
| Продукт 1 | Июнь | 12 |
| Продукт 2 | Июль | 5 |
| Продукт 3 | Август | 10 |

$\rightarrow$

| Продукт / Месяц | Июнь | Июль | Август |
| --- | --- | --- | --- |
| Продукт 1 | 12 | 24 | 5 |
| Продукт 2 | 
| ... |


OLAP кубы
Многомерное хранение неудобно с точки зрения можификации структуры

## Lecture #4

### БД:
- совместно используемый набор логически связанных данных и описание этих данных, прядназначенные для удовлетворения информационных потребностей организации. (Коннолли и Бегг)
- набор постояннохранимых данных, используемых прикладными системами какого-либо предприятия. (Дейт)
- совокупность специальным образом организованных данных, хранимых в памяти вычислительной системы и отображающих состояния объектов и их взаимосвязей в рассматриваемой предметной области. (Хомоненко)



### СУБД:
- ПО с помощью которого пользователи могут определять и поддерживать БД, а также осуществлять к ней контролируемый доступ. (Коннолли и Бегг)
- комплекс языковых и программных средств, предназначенных для создания, ведения и совместного использования БД многими пользователями. (Хомоненко)

> В современном мире: и средства позволяющие проектировать и создавать БД


###  Реляционная БД
- 1970 г. - появление реляционной БД + UNIX
- Кодд - `Relation model of data`
- 1980 г. - 12 правил реляционной СУБД
- Основа РМД - отношение `relation`
- Схема отношения - совокупность заголовков столбцов (1 строка таблицы).
- Кортеж - отдельная строка в таблице
- Атрибут - отдельный столбец таблицы
- Поле - пересечение кортежа и атрибута
- Домен - множество допустимых значений атрибута
- Степень отношения - количество атрибутов
- Кардинальность отношения - количество кортежей

### Cвойства РМД:
- уникальность имени отношения в реляционной схеме (каждая таблица имеет определенное имя)
- каждая ячейка содержит только одно неделимое значение (одно из самых тяжелых с точки зрения баталий и принятия решений)
> пример с записью номера телефона, предполагаем что поля неделимые
>
> парсинг номера телефона - возможная ошибка в целостности данных
- уникальность имени атрибута в пределах отношений
- значение любого атрибута берутся из одного и того же домена (домен определяет значения атрибута в столбце)
- каждый кортеж уникален
- порядок следования атрибутов и порядок следования кортежей не имеют значения (важное расхождение с формулировкой Кодда)
> все хорошо пока не начинаешь сортировать (выполнять другие операции) данные
> 
> берешь список и случайно одно из значений не на своей позиции, в отдельном случае - корректное выполнение поиска, в другом - ошибка при поиске
>
> большинство СУБД нарушают данное свойство
>
> триггеры - поверх БД весится проверка при добавлении / изменении новых данных, ускорение при чтении данных

### Ключи:
- Хранение связей осуществляется при помощи ключей
- Суперключ - атрибут или множество атрибутов, единственным образом идентифицирующее кортеж

<table>

<tr><th>Студент</th></tr>

<tr><td>

| Номер |  Ф | И | О | серия паспорта | номер паспорта | ... |
| --- | --- | --- | --- | --- | --- | --- |

</td></tr>

</table>

- Потенциальный ключ - суперключ, который не содержит подмножества, являющего суперключем (минимальный суперключ)
- простые
- составные
- первичный - один из потенциальных ключей, который выбран для уникальной идентификации кортежей данного отношения (`primary key`)
- внешний - атрибут или множество атрибутов, которые соответствуют первичному ключу некоторого, возможно, того же самого отношения (`foreign key`)

### Типы связей

- 1: 1
> Первичный ключ одного из отношений является одновременно и внешним ключем

<table>
<tr>
<td>

| Employee |
| - |
| id_exp (PK) |

</td>
<td>

| SalesPerson |
| - |
| id_sp (PK, FK) |

</td>
</tr>
</table>

- 1: М
> ???

<table>
<tr>
<td>

| Employee | |
| - | - |
| id_exp (PK) | id_boss(FK) |

</td>

<td>

| SalesPerson |
| - |
| id_sp (PK, FK) |

</td>
</tr>
</table>


- М: М
> использование таблиц связок
> реализация через таблицу связку, как минимум содержащую пару из ключей, связывающих таблицы

<table>
<tr>
<td>

| Employee | |
| - | - |
| id_exp (PK) | id_boss(FK) |

</td>

<td>

| SalesPerson |
| - |
| id_sp (PK, FK) |

</td>
<td>

| Product |
| - |
| id_pr |

</td>

<td>

| Region |
| - |
| id_reg |

</td>

</tr>

<tr>
<td>

| SalesPerson_Product | | |
| - | - | - |
| id_pr | id_sp | id_reg |

</td>
</tr>

</table>

Целостность:
- Сущностная целостность - ни один атрибут первичного ключа не может содержать Null значений
- Ссылочная целостность - если в отношении существует внешний ключ, то его значение должно соответствовать существующему значению потенциального ключа к другом отношении

## Lecture #5

> Реляционная алгебра в основе реляционной БД

Объект - отношение




### [Операции](https://habr.com/ru/post/145381/):
- Проекция: $П_{a_i, a_{i + 1}, ..., a_n} (R)$
> определяет новое отношение, содержащее вертикальное отношение данного отношения, создаваемое по средством смещение указанных атрибутов и исключения из результата строк дубликатов. (mb mistake)

- Выборка: $\sigma_{предикат} (R)$
> операция, которая определяет результирующее отношение, которое содержит только те кортежи из исходного отношения, которые удовлетворяют заданному условию(предикату)

- Объединение: $R \cup S$
> определяет новое отношение, которое включает все кортежи содержащиеся только в $R$,  которое включает все кортежи содержащиеся только в $S$, и кортежи содержащиеся в $R$ и $S$ без дубликатов.

> два отношения $R$ и $S$ совместимы, когда они состоят из одинакового числа атрибутов и каждая пара соответствующих атрибутов будет иметь одинаковый домен

- Разность: $R - S$
> отношение, которое состоит из кортежей, которые есть в отношении $R$, но отсутствуют в отношении $S$
> требуётся совместимость по объединению

- Пересечение: $R \cap S$
> отношение, которое содержит кортежи как в отношении $R$, так и в отношении $S$

- Декартово произведение: $R \times S$

> определяет новое отношение, которое является результатом какой-то комбинации каждого кортежа из отношения $R$ с каждым кортежем из отношения $S$.

- Тета соединение: $R \bowtie_F S$, $F = R_{a_i} \theta S_{b_i}$, $\theta \in [\leqslant, \geqslant<, >]$

> определяет новое отношение, которое содержит кортежи из декартового произведение $R$ и $S$ удовлетворяющие предикату $F$, где $F$ ...

эко-соединие - 

- Естественное соединение:  $R \bowtie_F S$
> соединие по эквивалентности двух отношений, выполененное по всем общим атрибутам, из результатов которого исключается по одному экземпляру каждого общего атрибута

- Левое внешнее соединение: $R \supset \triangleleft S$
> тета соединение, при котором результирующее отношение включаются так же кортежи отношения $R$ не имеющих совпадающих значений в общих столбцах отношения $S$

- Полусоединие: $R \triangleright_F S$

> те кортежи из $R$ которые входят в соединение $R$ и $S$


### SQL

- не процедурный язык

```SQL
SELECT [DISTINCT | ALL] { * | [ColumnExpression] [AS NewName]], [...]}
FROM Table1 [AS NewName]
    [{INNER | LEFT OUTER | FULL} JOIN] Table2 [AS NewName]
        ON condition
[WHERE condition]
[GROUP BY ColumnList]
[HAVING condition]
[ORDER BY ColumnList [ASC | DESC]]

# FROM -> [JOIN ... ON] -> [WHERE] -> [GROUP BY] -> [HAVING] ->
# SELECT -> [DISTINCT] -> [ORDER BY]
```
