# tickets-OS

## 1. Функции и механизмы ОС, появившиеся на этапе программ- диспетчеров, предшественников операционных систем.

На данном этапе термин ОС не существует (но ряд функций, которые стали в последствии функциями ОС появляются на этом этапе).

Проблемы и механизмы решения:

1. Повторное использовние кода; автоматизация загрузки и линковки.
    
    > При увеличении сложности программ, стало необходимым повторное использование кода. 
    Например : переиспользование тригонометрических функций.
    > 
    > 
    > **Идея** : в области RAM фиксируется область, в которую помещаются часто используемые программы. В основной программе - вызов программы из упомянутой области. Необходима система управления для идентифиакции адресов внутри фиксированной области; для передачи параметров программе и корректной обработки результатов при возвращении из области в основную программу.
    > 
2. Оптимизация взаимодействия с устройствами хранения, ввода-вывода.
    
    > Так как загрузка всех данных в RAM невыгодна (часть данных может быть никогда не ис- пользована), необходим иной подход.
    > 
    > 
    > **Идея** : загрузка части данных, их обработка и последующая выгрузка (циклический подход). Необходимо участие CPU как посредника для синхронизации данных этапов. Тогда, к классической архитектуре Фон Неймана необходимо добавить контроллер, который позволил бы совершать эти действия параллельно (например, контроллер отвечал бы за перемещение данных из хранилища в RAM и занимался этим пока CPU обрабатывает другие данные из RAM, а не простаивает в ожидании). Для избежания обработки неготовых данных или замены еще не обработаных или обрабатываемых (избежания коллизий), необходима синхронизация контроллера и CPU. Для этого был создан механизм прерывания (interrupts).
    > **SPOOL** - Simultaneous Peripheral Operation OnLine - обеспечение взаимодействия с пере- ферийным устройством параллельно с работой основного вычислительного узла.
    > **Прерывание** - сиганл, поступающий от внешнего устройства к CPU, сообщающий о наступлении некоторого события и в результате которого CPU прекращает выполнение текущего набора команд и передает управление программе-обработчику прерываний
    > 
3. Однопрограммная пакетная обработка
    
    > Наличие множества компонентов программного кода. Появляется необходимость хранения данных(конcтант, массивов и т.д.), программ для их обработки (и возможно чего-то еще) совместно
    > 
    > 
    > **Идея** : объединение данных, программных компонентов для совместной работы (пакет). Данное решение позволяет во время работы одного пакета подгружать другой. Как следствие появляется задача однопрограммной пакетной обработки(разные заказчики пакетов, которые, возможно, готовы платить больше чтобы их пакет обработался быстрее). Отсюда появление очереди и необходимости управления ею(приоретизации).
    > 

## 2. Функции и механизмы ОС, появившиеся на этапе муль- типрограммных операционных систем.

Отсутствует возможность эффективно использовать ресурсы системы, так как для раз- ных программ в разные моменты времени могут понадобиться различные объемы ресур- сов(например одной программе необходимо мало данных для большого количества вычисле- ний, а другой много данных для малого количества вычислений).

Проблемы и механизмы решения:

1. Обеспечение разделения времени процессора
    
    > Возможность использования ресурсов процессора несколькими приложениями (переключения между приложениями).
    **Идея** : на аппаратном уровне появление таймера (для еще одного механизма прерывания). Генерация прерывания по таймеру, для решения задачи о переключении. Необходимость кор- ректного возврата в состояние приложения до прерывания (сохранение регистрового контекста - также решается аппаратно).
    > 
2. Обеспечение разделения памяти
    
    > На этапе разработки неизвестно нахождение адресов используемых приложений в памяти.
    > 
    > 
    > **Идея** : появление механизма виртуальной памяти (каждое приложение имеет собственное виртуальное пространство, отсчитываемое с нуля; физическая память в последствии выпол- няет пересчет адресов).
    > 
3. Защита деятельности программ от деятельности других программ
    
    > У одной программы есть возможность обратиться к адресам памяти, которые содержат дан- ные другой программы.
    > 
    > 
    > **Идея** : наличие проверок на аппаратном уровне (наличие еще одного прерывания); избе- жание обращения к несуществующему участку памяти.
    > 
    > Необходимо расширение с защиты памяти на защиту любых ресурсов.
    > 
4. Планирование использования ресурсов(I/O, CPU, RAM и т.д.) и исполнения программ
    
    > Усложнение планировщиков (необходимо учитывать алгоритмы действия данной выполняе- мой программы).
    > 
5. Синхронизация работы различных приложений
    
    > Невозможность использования неразделяемого ресурса несколькими программами (синхро- низация работы приложний относительно ресурсов).
    > 
6. Обеспечение универсального доступа к устройствам хранения
    
    > При наличии в памяти программ, работающих параллельно, обращение к памяти происходит постоянно (наличие сложной адресации).
    > 
    > 
    > **Идея** : появление файлово-каталожной системы.
    > 
    > *Для эффективного использования системы используется большое количество системного кода*
    > 
    > Концепция ОС как слоя абстракции между пользовательским ПО и железом. Как следствие концепция виртуальной машины для каждого приложения - оно не знает реальных ресурсов вычислительной системы и "живет в коробке"
    > 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image1.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image1.jpeg)

## 3. Функции и механизмы, появившиеся на этапах сетевых и мобильных (универсальных) операционных систем.

## Сетевые операционные системы

Узкое место у предыдущих систем - работа с единым терминалом (input -> CPU).

Проблемы и механизмы решения:

1. Необходимость универсальности ОС относительно различных архитектур ЭВМ
    
    > Появлиось много ЭВМ и еще большего количество терминалов для доступа к ним. Как след- ствие появилась необходимость универсальности ОС для объеденения вычислительных узлов различной архитектуры в единую систему(для повышения эффективности и распределения нагрузки)
    > 
2. Необходимость идентификации личности
    
    > **Идея** : (ауентификация и авторизация) контроль доступа к ресурсам вычислительного уз- ла из вне.
    > 

## Универсальные (мобильные, открытые) системы

Разнообразие операционных систем тормозит развитие отрасли информационных технологий (повторное использование кода, сложности с переносимостью между системами).

Система должна стать универсальной, относительно различных архитектур и платформ (под- держка разработки приложений на языке высокого уровня).

Проблемы и механизмы решения:

1.  Создание ОС на языке высокого уровня
    
    *Идея* : 1969 год - Bell Labs - cоздание языка С и опреционной системы UNIX (UNICS)
    

## 4. Задачи и механизмы, реализуемые в рамках функции операционной системы по обеспечению интерфейса меж- ду пользовательскими приложениями и аппаратным обес- печением вычислительного узла.

### Управление разработкой и исполнением пользовательского ПО

1. API - Application Program Interface - интерфейс для прикладного программирования (ин- струментарий для разработки); описание способов взаимодействия программ.
2. Механизм для загрузки и исполнения Software (инструмент управления исполнением).
3. Обнаружение и обработка ошибок.
4. Высокоуровневый уровень доступа к устройствам ввода-вывода (для пользователя не важ- ны физические параметры устройств и т.д).
5. Реализация управления доступа к хранилищу (обеспечение корретной обработки файлов вне зависимости от файловой системы, обеспечение прав доступа между файлами).
6. Мониторинг использования ресурсов.

## 5. Принципы организации эффективного использования ресурсов компьютера. Критерии эффективности. Под- ходы к решению многокритериальной задачи.

### Оптимизация использования ресурсов

Решение многокритериальных задач принятия решений :

(для работы нескольких программ требуется использование и памяти, и ресурсов процессора. Необходимо использовать и то, и другое эффективно) При наличии нескольких критериев (К1, К2, К3 и др.) и при попытке максимизации одного из них, невозможно максимизировать и остальные критерии.

Решения :

1. *Использование взвешенных критериев (свертка критериев)*.
    
    > K* = a * K1 + b * K2 + c * K3 + ..., где a + b + c + ... = 1 (весовые коэффициенты). Поиск варианта, при котором значение суперкритерия K* будет максимальным.
    > 
    > 
    > **Проблема** : недопустимость значения одного из критериев.
    > 
    > Так как необходимо обеспечить лучшее время отклика (например, для систем реального вре- мени), вводят условный критерий :
    > 
    > Поиск максимума для одного из критериев, при наличии ограничений на другие критерии.
    > 
2. *Использование цикла Деминга (PDCA)*.
    
    > Plan (формирование коэффициентов или выбор алгоритма планирования) - Do (последо- вательное выполнение плана) - Check (проверка предсказанных и полученных результатов, достижения целевых показателей) - Act (решение проблем планирования).
    > 

## 6. Виды архитектур ядер операционных систем. Общая характеристика каждого вида, достоинства и недостат- ки.

Ядро ОС - часть кода, которая в совокупности обладает следующими характеристи- ками : ему присуща резидентность (код ядра весь период эксплуатации находится в опера- тивной памяти в неизменных адресах), и он работает в привелегированном режиме (код не ограничен проверками на доступ к адресам памяти и ему доступны некоторые специальные инструкции процессора).

Виды архитектур :

1. *Монолитная архитектура* - Вся ОС в ядре.
    
    > + Быстро(все внутри)
    > 
    > 
    > + Безопасно(Одна точка входа для пользовательского ПО)
    > -  Занимает много RAM на постоянной основе
    > -  Проблемы с надежностью(Много кода в привилегированном режиме)
    > -  При замене части кода ядра необходима пересборка
    > 
    
    1.1 Модульная архитектура - модификация монилитной архитектуры, которая не требует полной перекомпилции ядра при изменении состава аппаратного обеспечения компьютера. Модульные ядра предоставляют механизм подгрузки модулей ядра.
    
2. *Микроядерная архитектура* - Часть слоев из многослойной архитектуры(базовые меха- низмы и ниже) остается в ядре, часть - переносится за преде-лы ядра.
    
    > + Снижается размер кода ОС в RAM
    > 
    > 
    > + Удобно для распределенных систем
    > 
    > + Удобно для переходов между различными архитектурами(переписывается лишь часть кода)
    > -  Много переключений между пользовательским режимом и привилегированным
    > -  Проблемы с безопасностью(у кода многих компонентов ОС нет защиты от вмешательств пользовательского на аппаратном уровне)
    > 
3. *Гибридная архитекрура* - ядро, в котором возможна замена части кода с кода ядра на код, выполняемый в пользовательском режиме.
4. *Нано-ядро* - в ядре остается лишь обработка прерываний (иногда - низкоуровневые плани- ровщики).
5. *Экзо-ядро* - попытка построения ОС над оборудованием с различными характеристика- ми.
    
    > Ядро -> принятие решений и межпроцессное взаимодействие. 
    Вне ядра -> взаимодействие с оборудованием.
    > 

## 7. Монолитная архитектура операционной системы. По- дробное описание компонентов (слоев), их назначение и взаимодействие между собой. Достоинства и недостат- ки монолитной архитектуры ядра.

Монолитная архитектура - схема операционной системы, при которой все компонен- ты её ядра являются составными частями одной программы, используют общие структуры данных и взаимодействуют друг с другом путём непосредственного вызова процедур (весь функционал реализован в режиме ядра).

Слои :

Software
$\Updownarrow$
1) Main Program - интерфейс для внешнего пользовательского ПО (получение и переадреса- ция сервису для выполнения системного вызова).
$\Updownarrow$
2) Services - принятие решений и их реализация с помощью утилит.
$\Updownarrow$
3) Utilities - протокол взаимодействия с контроллером соответственного экземпляра ПО.
$\Updownarrow$
Hardware

> + быстрота взаимодействия
+ безопасность (обращение пользовательского ПО только к main program)
-  надежность (Много кода работает в привилегированном режиме сбой в одном из компонентов может нарушить работоспособность всей системы)
-  занимает много RAM;
-  при замене части кода ядра необходима пересборка
> 

## 8. Концепция многослойного ядра операционной системы. Подробное описание слоев, их назначение.

Структура ОС, представленная рядом слоев (каждый слой обслуживает вышележащий слой, выполняет для него некоторый набор функций).

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image2.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image2.jpeg)

## 9. Микроядерная архитектура операционной системы. По- дробное описание компонентов, их назначение и вза- имодействие между собой. Достоинства и недостатки микроядерной архитектуры ядра.

Часть слоев из многослойной архитектуры остается в ядре, часть - переносится за преде- лы ядра.

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image3.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image3.jpeg)

> + уменьшение объемов памяти, которые выделяются для ОС
> 
> 
> + удобство в построении распределенных систем
> 
> + быстрота и удобство при переходе между различными архитектурами
> -  количество переключений между user и kernel mode сильно снижают производитель- ность
> -  проблемы с надежностью и безопасностью (при вынесении кода в user mode снижает- ся надежность системы в целом; сложнее обеспечить безопастность из-за отстутствия аппаратной защиты некоторых компонентов ОС).
> 

## 10. Понятия процесса, потока, нити, задания. Их опреде- ления, назначение и различия между собой.

**Process (Процесс)** - совокупность набора исполняющихся команд, ассоциированных с ним ресурсов и контекста исполнения, находящиеся под управлением ОС.

Создание процесса ⇒ создание Process Control Block(PCB или дескриптора процесса) - пред- ставления процесса в памяти ОС.

**Thread(Поток)** - отдельный набор команд и контекст, имеющие доступ к одному адрес- ному пространству (более широко - к ресурсам в целом)

**Проблема**: Многозадачность потоков в большинстве случаев опирается на механизмы ОС для переключения между потоками, что может повлечь за собой неэффективное использование ресурсов(сама выполняемая задача не имеет управления над процессом своего выполнения)

**Волокно (нить)** - облегченный поток(в какой-то мере подпоток) - позволяет решить проблему кооперативной многозадачности: само волокно отдает управление либо следущему волокну, либо волокну-диспетчеру. Таким образом выполняемая задача сама управляет сво- им выполнением

**Job (c-group/задание/работа/контрольная группа)** - "надпроцесс" - совокупность исполняемых операций над данными, набор квот для ресурсов.

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image4.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image4.jpeg)

## 11. Функции подсистемы управления процессами.

1. Создание процессов и потоков
2. Обеспечение ресурсами процессов
3. Изоляция процессов друг от друга
4. Планирование процессов и потоков на разных условиях. Решение в каком доступе и объеме необходимо предоставить доступ к ресурсам
5. Диспетчеризация - переключение процессов между различными исостояниями; движение по жизненному циклу процесса
6. Взаимодействие между процессами
7. Синхронизация - обеспечение одновременного исполнения условий исключений, наличие прогресса, отсутствие голодания и др
8. Уничтожение процессов в конце их работы

## 12. Методы создания процессов в различных операцион- ных системах. Структуры данных о процессах

Структуры данных:

Process Control Block или дескриптор:

> 1. Идентификация процессов (PID, часто PPID - UID и др.)
2. Информация о состоянии процесса (статус и контекст)
3. История процесса
> 

Иерархия процессов (некоторый граф, часто - дерево)

Создание процессов в различных системах: 

> Linux:
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image5.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image5.jpeg)

> Windows:
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image6.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image6.jpeg)

## 13. Модель жизненного цикла процесса: состояния про- цесса, правила переходов между состояниями

> Linux:
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image7.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image7.jpeg)

## 14. Виды планирования и их место в жизненном цикле процесса

Планирование - (исторически) распределение CPU-time между процессами при соблю- дении требований

**Проблема**: Есть набор процессов из которых выстраивается очередь, но при этом реаль- ное время исполнения - случайная величина, + система открытая ⇒ ее состояние постоянно меняется ⇒ изначальная очередь(особенно длинная) может стать неэффективной

**Горизонт планирования** - число процессов, после выполнения котороых вызывается прерывание и происходит перепланирование. "Дальновидность"планирования.

**Проблема**: Планирование занимает время. Часто планировать - эффективно, но дорого.

Редко - дешево, но неэффективно.

**Решение**: Разное планирование в разных местах

- Краткосрочное планирование: быстрое, не самое эффективное, но это не страшно, так как горизонт планирования невелик
    
    Например: Этапы готовность исполнение. Удобно, так как кванты времени для каж- дого процесса на CPU очень малы
    
- Среднесрочное планирование: не самое быстрое, более эффективное, средний гори- зонт планирования.
    
    Например: Этап ожидания (ожидание в RAM ожидание вне RAM). Если мы знаем, что процесс в ближайшее время будет ждать, мы можем заменить его в RAM на другой процесс
    
- Долгосрочное планирование: самое эффективное, хоть и долгое, но это не страшно, так как оно происходит не так часто
    
    Например: Этапы рождение готовность. Если мы позволим процессу родиться, он будет использовать ресурсы машины долгое время, поэтому здесь планирование должно быть максимально эффективно
    

## 15. Критерии эффективности и свойства методов плани- рования процессов, параметры планирования процес- сов

Критерии планирования:

- Справедливость - гарантия каждому заданию равной доли CPU-time или другого ресурса системы
- Эффективность - раздача ресурсов по потребности. Максимальная загруженность ресурсов
    
    Критерии эффективности:
    
    - Cокращение полного времени выполнения(от рождения до смерти)
    - Cокращение времени ожидания
    - Cокращение времени отклика Свойства методов планирования:
- Предсказуемость - на одинаковых данных одинаковые или схожие результаты
- Минимальные накладные расходы - низкое время выполнения
- Масштабируемость на количество возможных ресурсов Параметры планирования:

[Параметры планирования](https://www.notion.so/b6a2e88472a2461fb94776a7e9baafa0)

## 16. Методы планирования без внешнего управления при- оритетами (FCFS, RR, SJF), гарантированное плани- рование: описание, преимущества и недостатки

**Невытесняющее планирование** - если процесс начал выполняться он может прервать себя лишь сам (завершиться или уйти в ожидание)

**Вытесняющее планирование** - есть механизм прерывания выполнения текущего про- цесса для начала выполнения другого

$*τ_{полное}*$ - Полное время выполнения всех процессов от начала первого до конца последнего 
$*τ_{исполнения}*$ - Среднее для всех (время ожидания в готовности + время выполнения) $*τ_{ожидания}*$ - Среднее время ожидания

- First Came First Served(FCFS, кто первый встал того и тапки)
    
    > + Не вызывает голодания процессов
    > 
    > 
    > + Эффективен если процессы в очереди выстроены в порядке возрастания полного времени выполнения
    > -  Максимально неэффективен если процессы в очереди выстроены в порядке убывания полного времени выполнения
    > -  По сути эффективность - случайная величина
    > 
- Round Robin(RR, Круглый Робин(карусель))
    
    > + Прост
    > 
    > 
    > + Очень эффективен при правильном кванте
    > -  При неправильном кванте вырождается в FCFS (если очень большой), или душит накладными расходами на переключения (если оч малый)
    > 
- Shortest Job First (Кто короткий тот вперед).
    
    > Начинает выполнять самый быстрый про- цесс в течение определенного кванта, за- тем, если есть более короткий процесс пе- реключается на выполнение его
    > 
    > 
    > + Дает кратчайшее время ожидания
    > 
    > + Оптимален для пакетной обработки ко- гда время ожидания не критично
    > -  Провоцирует голодание длинных про- цессов
    > 
- Гарантированное планирование
    
    > $N$ - количество процессов
    > 
    > 
    > $*T_i*$ - время сеанса i-го процесса
    > 
    > $*τ_i*$ - время выполнения i-го процесса
    > 
    > $*τ_i*$ ∼ $*\frac {T_i} {N}*$ , $*R = \frac {τ_i·N} {T_i}*$
    > 
    
    > + Разделяет ресурсы между процессами поровну
    -  Как следствие часто неэффективен
    -  Сложные вычисления коэфициента справедливости R
    > 

## 17. Приоритетное планирование с внешним управлением приоритетами, многоуровневые очереди. Описание ме- тодов, их достоинства и недостатки

**Приоритетным планированием** - планирование, при котором каждому процессу при- сваивается определенное числовое значение – приоритет.

Приоритет может задаваться как внутренними критериями системы (например, длитель- ность CPU-Burst для SJF), так и внешними по отношению к системе (например, важность для пользователя).

Многоуровневые очереди:

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image9.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image9.jpeg)

**Проблема**: голодание процессов низкого приоритета

**Решение**: после таймаутра повышеть при- оритет процесса, а затем, после некоторого времени выполнения - отбрасывать назад

Многоуровневые очереди с обратной связью:

> Для каждой очереди квант разный. Как только процесс рождается он считается хорошим и попадает в самую приоритетную очередь. Если он успевает выполниться (или уйти в ожида- ние) за этот квант его приоритет остается. Если нет, его приоритет понижается. При этом с понижением приоритета очереди увеличивается квант выполнения.
> 

## 18. Организация планирования процессов в ОС семейств Microsoft Windows

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image10.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image10.png)

1. Классы приоритетов:
    - Realtime 24
    - High 13
    - Above normal 10
    - Normal 8
    - Below normal 6
    - idle 4
2. Уровни насыщения(для управления приоритетами)
    - Time-critical +15
    - Highest +2
    - Above normal +1
    - Normal ± 0
    - Below normal -1
    - Lowest -2
    - Idle -15

Внешнее управление приоритетом:

> Создание процесса $\xRightarrow{\text {система вызова для потока}}$ изменение приоритета потока при этом между Real-time и Dynamic потоки переходить не могут.
> 

Внутреннее управление приоритетом:

> Для Dynamic система может менять приоритеты процессам в зависимости от их статуса. При этом интерактивным процессам повышается приоритет (так как они интерактивные). Если они успевают выполниться или уйти в ожидание за квант в очереди с более высоким приоритетом, они там и остаются. Если нет, их приоритет понижается на 1 до изначального.
> 

## 19. Принципы работы планировщиков O(1) и CFS в опе- рационных системах GNU/Linux

Linux O(1):

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image11.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image11.jpeg)

+ 2 очереди, а значит нет голодания

-  Высокие накладные расходы на расчет интерактивности и других коэффициентов

**Linux CFS:**

Для каждого процесса существуют две переменные: exec_time(время, которое процесс в сум- ме выполнялся) и max_exec_time(время, которое процесс будет выполняться в следующий раз, когда попадет на CPU). max_exec_time рассчитывается так, чтобы было "честно"по отношению к другим процессам. Фактически: *τ*ожид

Массив процессов упорядочен по возростанию exec_time. Следующим на выполнение вы- бирается процесс с наименьшим exec_time. Во время выполнения exec_time растет. После достижения max_exec_time процесс перестает выполняться и улетает обратно в массив в соответствии со своим exec_time (чтобы массив оставался упорядочен).

Внешнее управление приоритетами достигается за счет изменения max_exec_time и более приоритетные процессы просто получают больше времени на выполнение когда придет их очередь.

В силу используемых структур данных (в частности - красно-черного дерева), доставание процесса осуществлсяется за O(1), а вставка и удаление за O(log(n))

Еще существует понятие **гранулированности** - минимальная величина max_exec_time. Та- ким образом снижение общих накладных расходов на переключения при высоких загрузках.

В обоих планировщиках своя очередь для каждого CPU. Раз в определенный промежуток времени происходит ребалансировка процессов по процессорам

## 20. Взаимодействие процессов. Условия взаимоисключе- ния и прогресса. Понятие критической секции. Голо- дание процессов

**Внешне-определенное взаимодействие** - обеспечение возможности процессам обме- няться данными или управлением.

**Вынужденное взаимодействие** - ситуация при которой процессы начинают конкури- ровать за неразделимый ресурс.

Необходимые условия которые должны обеспечиваться при взаимодействии процессов:

- Взаимоисключение доступа процессов к неразделяемому ресурсу
    
    > Критическая часть кода относительно ресурса - та часть кода которая непосред-
    > 
    > 
    > ственно осуществляет взаимодействие с неразделимым ресурсом
    > 
    > Задача: два или более процессов не могут одновременно находиться в критических частях кода относительно одного и того же ресурса
    > 
    > *Решение*: Пролог и эпилог - обозначения точек кода начала и конца взаимодействия с неразделимым ресурсом (для сообщения ОС о начале и окончании работы с ним)
    > 
- Прогресс
    
    > Не должно возникнуть ситуации когда(одновременно):
    > 
    > - Ресурс свободен
    > - Есть процесс, которому нужен данный ресурс для работы
    > - Процесс не может использовать данный ресурс
    > 
    > **Причины**: недостатки алгоритмов планирования или механизмов их реализации
    > 
- Отсутствие **голодания** - длительного (потенциально бесконечного) отсутствия доступа у процесса к запрашиваемому ресурсу
- Отсутствие тупиков - ситуаций, когда процессы не могут ни получить запрашиваемый ресурс и ни при этом разблокировать уже занятый ими ресурс, чтобы дать возможность другим процессам выполниться и потенциально разблокировать первый ресурс.

## 21. Алгоритмы реализации взаимоисключений. Формаль- ное описание алгоритмов, их недостатки

Подходы к решению задачи по планированию с соблюдением необходимых условий взаи- модействия процессов:

Аппаратный уровень:

- Идея: Дать ресурсу право не отдавать ресурс пока работа с ним не закончена Проблема: Вытесняющая многозадачность ⇒ нельзя.
- Идея: Запрет на прерывания во время выполнения критической части кода
**Проблема**: Работа неэффективна (нарушается работа планирочщика) + потенциально неуправляемый сломавшийся процесс и вечно заблокированный ресурс Алгоритмы взаимоисключения:
1. Замок 

> Если произойдет прерываение $*P_0*$ на между строками 4 и 5, то $*P_1*$ сможет начать выполнение критической секции. При этом если произойдет его прерывание в ней, в свою критическую секцию перейдет и $*P_0*$ ⇒ Нарушение взаимоисключения
> 

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled.png)

1. Строгое чередование

> Возможно, что *P*0 завершил работу с ресурсом и передал его *P*1, но тот ждет и ресурс не использует. За это время процессу *P*0 может снова потребоваться ресурс, но он его не получит, так как *P* еще с ним не отработал
> 

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%201.png)

1. Флаги готовности

> Если произойдет прерываение P0 на между строками 4 и 5, то P1 встанет в готовность, увидит, что есть другие и будет ждать. Когда снова начнет выполняться P0 он увидит, что есть процессы, которые готовы и так же будет ждать ⇒ Тупик
> 

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%202.png)

1. Алгоритм Петерсона

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%203.png)

> Все условия выполняются, но долго ⇒ возврат к аппаратному подходу Решение: Создание новой сложной команды команды CPU, так как для решения про- белмы достаточно запретить прерывания на строках 4-5 алгоритма замка. Новая команда Test&Set опрашивает переменную, и если ее значение равно нулю, то ей присваивается единица и одновременно возвращается true. Иначе возвращается false и изменения переменной не происходит 
⇒ Test&Set - аппаратная поддержка условия взаимосиключения
> 

Обновленный замок: 

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%204.png)

## 22. Семафоры Дейкстра. Решение проблемы «производитель- потребительc с помощью семафоров

Пусть результат работы одной команды идет на вход другой.

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image12.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image12.png)

Возникают потенциальные проблемы:

> 1. Одновременные запись и чтение (так как они не мгновенны - неконсистентность данных) 
2. Переполнение буфера
3. Чтение пустого(необновленного) буфера
> 

**Семафор** - целая неотрицательная переменная 

Механизм семафора Дейкстры:

Существуют 2 операции:

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%205.png)

Решение проблемы производителя и потребителя при помощи семафоров:

Объявление семафоров:

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%206.png)

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%207.png)

## 23. Проблемы взаимодействующих процессов. Проблема обедающих философов, проблема писателей и читате- лей

Проблемы взаимодействующих процессов - обеспечение условий взаимоисключения, прогрес- са, отсутствия голодания, отсутствия тупиков.

**Livelock** - что-то делается, но беспродуктивно 

**Deadlock** - вообще ничего не делается 

Проблема обедающих философов

> Для того, чтобы поесть пельмешей надо 2 вилки. При этом вилка - критический ресурс, не все могут одновременно его использовать
> 

> **Решение**: Взять левую вилку, если пра- вой нет - положить левую и ждать.
Однако даже при случайном времени ожи- дания есть шанс, что случится lock
**Решение**: Официант (ОС)
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image13.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image13.jpeg)

Проблема читателя и писателя

> Для того, чтобы поесть пельмешей надо 2 вилки. При этом вилка - критический ресурс, не все могут одновременно его использовать.
> 

> **Решение**: Единая очередь |r|r|r|w|r|r|r|r|w| При этом чтения можно производить парал- лельно
**Потенциальная проблема**: Частое чередование
**Возможное решение**: Механизмы пере- группировки
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image14.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image14.png)

Однако такое решение является частичным, и возможно лишь тогда, когда чтение и запись не связаны

## 24. Тупики. Условия возникновения и методы борьбы с тупиками

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%208.png)

**Тупик** - ситуация, в которой для продолже- ния выполнения процессу P0 нужен заблокированный ресурс R2, и при этом сам этот процесс держит другой неразделимый ресурс R1. Процессу P1, который заблокировал ресурс R2, для продолжения нужен ресурс R1, который заблокировал P0. Таким образом образуется тупик, в котором процессы P0 и P1 держат друг другу нужные ресурсы и не отпускают

Условия возникновения тупиков (по Кофману):

> 1. Mutual Exclusion
2. Hold&Wait
3. No Preemption (нет возможности отобрать)
4. Сircle Await (Deadlock meets Round Robin) 3 пути:
> 

3 пути:

> 1. Игнорировать → очень дешево и не так страшно
2. Предотвращать → оптимально
3. Обнаруживать и восстанавливать → дорого
> 

Пути предотвращения тупиков:

> 1. Буферизация (против Mutual Exclusion)
2. Блокировка всех неразделяемых ресурсов (против Hold&Wait)
3. Отбитрать у слабых процессов ресурс, забуферизовав его состояние (против No Preemption)
4. Нумеровать ресурсы и давать процессу только номером выше тех, что у него уже есть, периодически сдвигая номера (против Circle Await) → дорого
> 

На самом деле все полумеры, хоть и везде частично реализованные. На практике часть ту- пиков все равно игнорируется.

## 25. Принципы управления памятью вычислительной си- стемы. Виртуальная память и преобразование адресов

3 свойства компьютерной памяти

> 1. Чем быстрее тем дороже
2. Чем выше объем тем дешевле
3. Чем выше объем тем медленнее
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image16.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image16.jpeg)

**Идея**: Виртуализация - Расширение RAM при помощи места в хранилище с созданием единого адресного пространства.

**Своппинг** - процесс переноса данных между хранилищем и RAM. 

**Подходы**: Переносить все данные процесса или фрагментами?

1. Windows: Файл подкачки(работает через стандартный механизм ФС)

> + Стандартные механизмы работы с файлами на диске
+ Простое управление размером: файл может увеличиваться и уменьшаться 
-  Работа через абстракцию файловой системы без ее фактического использования
-  Свойства и атрибуты файла не нужны, они определены заранее и не будут изменены Накладные расходы и снижение надежности
> 
1. Linux: Отдельный раздел диска

> + отдельный раздел (надежно, безопасно, эффективно)
-  размер (разделять или переразделять диск сложно долго и дорого)
> 

Пересчет адресов

- Перемещающий загрузчик: Расчет адресов на этапе загрузки программы в RAM.
    
    > + Простая защита памяти
    > 
    > 
    > + Быстрое обращение
    > -  Долгая загрузка
    > -  Проблема при расположении фрагментами ⇒ Много (долгих) пересчетов при свопе 
    > 
    
    Неудобное решение, если не использовать непрерывное пространство для всего процесса
    
- Динамическое преобразование: в момент загрузки адреса виртуальные, пересчитыва- ются при обращении.

## 26. Методы распределения оперативной памяти без использования внешней памяти

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image17.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image17.jpeg)

## 27. **Страничная организация виртуальной памяти. Вычис- ление физических адресов при страничной организа- ции виртуальной памяти**

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%209.png)

**Идея**: 

> Сегментное выделение как в динамическом разделении без swap’а, только с тем исключением, что сегмент может быть скинут в подкачку
> 

**Проблема**: 

> Как и в динамическом разделении сложные расчеты + фрагментированность
> 

Наиболее общепринятый вариант - страничный подход:

Разделение памяти на страницы одинакового разме- ра (1/2/4/...Кб - кратно степеням 2). Перерасчеты и размещения - тоже страницами.

**Проблема**: 

> Как найти нужные страницы?
> 

**Решение**: 

> Использование таблиц для адресации.
> 

Каждая строка таблицы строго соответствует странице в виртуальной памяти процесса

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image19.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image19.png)

Адрес состоит из адреса страницы и смещения. При обращении адрес виртуально страницы при помощи page_table за- меняется на адрес физической страницы

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%2010.png)

Для навигации по PT используется лишь ее адрес в памяти и номер страницы в виртуальной памяти, тк строки в ней строго соответствуют

Если страница находится в подкачке, вызывается страничное прерывание, процесс на- правляется в непрерываемое ожидание, запускается механизм страничного обмена и после его завершения процесс направляется в готовность.

Биты заголовка:

- M - бит памяти. 1 - в RAM, 0 - в подкачке
- А - бит доступа. 1 - если к странице было обращение после страничного обмена. В случае если свободных страниц в RAM не хватает в первую очередь меняются страницы с А = 0. В Linux - списки неактивных страниц и своп их в первую очередь.
- W - write_bit - равен 1 если с момента последнего страничного обмена данные на странице изменились и ее предыдущую копию в свопе, если она есть, при перемещениистраницы в него надо перезаписать. Если он равен 0, то страница при необходимости просто заменяется в RAM без долгой перезаписи свопа а вместо этого просто возвра- щается адрес ее старой копии.

**Проблема**: 

> Пусть выделено по 4 байта на страницу в таблице. Тогда при 32-битной адресации размер таблицы страниц равен 4Мб. Для 200 процессов это уже Гигабайт ⇒ невыгодно
> 

**Идея**: 

> Иерархическая организация страниц. Разобьем каждую pt на блоки по 4Кб и будем хранить для каждого такого набора каталог таблиц страниц.
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image21.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image21.jpeg)

Таким образом мы сокращаем минимальный необходимый объем для хранения информа- ции о страницах с 4Мб до 4Кб для каждого процесса

## 28. Методы оптимизации потребления ресурсов при стра- ничной организации виртуальной памяти. Сегментно- страничная организация виртуальной памяти

**TLB-кэш:**

- кэш для сохранения строк из pt к которым последний раз было обращение. Ассоциатив- ный массив (номер виртуальной страницы строка в pt).

В общем случае CPU может за очень короткое время опросить весь массив TLB и получить необходимый адрес. Сложный расчет адреса лишь если строки в кэше нет. (Не так часто, так как чаще всего код и данные, которые он обрабатывает находятся на одной странице)

**Сегментно-страничная организация:**

> Для ускорения работы для каждого сегмента держит- ся его активная страница в памяти
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image22.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image22.jpeg)

**Page-cache** - набор страниц, в которых находятся данные назначенные для записи в файлы. Сохраняет время, но не очень надежно и безопасно, тк при потере питания часть данных может быть утрачена

## 29. Метод оргназизации хранения данных в файловы системах: непрерывная последовательность блоков, связный список, таблица размещения файлов

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image23.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image23.png)

- Непрерывная последовательность блоков

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%2011.png)

> + Простая реализация
-  Фрагментация
*Пример:* CDFS
> 
- Связный список
    
    Последними 4 байтами блока хранить ссылку на следующий блок
    
    > + Нет фрагментации
    -  При потере одного блока теряются остальные
    -  Низкая производительность
    -  Неделимость размера блока или хранилища данных на 2
    > 
- Отдельная структура (Таблица размещения файлов)

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image25.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image25.png)

> + Максимально простая ⇒ поддерживается всеми
-  При потере таблицы теряется все ⇒ резервные копии
-  Необходимо хранить всю таблицу в RAM
> 

## 30. Метод оргназизации хранения данных в файловы системах: индексные дескрипторы

**На примере ext2:**

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image26.jpeg](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image26.jpeg)

> + Надёжность – потеряли 1 i-node – потеряли 1 файл, а не всё.
> 
> 
> + Каталог хранит только 2 поля: имя и i-node, без размера.
> 
> + Эта модель позволила создать сетевой каталог.
> 
> + Общение с файлами "по ссылке". Изменения в одном файле с одним именем заденут "другой"файл с другим именем в другом месте если их дескриптор одинаков
> 
> -  Заранее ограничено количество файлов.
> 

## 31. Журналируемые файловые системы. Назначение и ви- ды журналов

Для того, чтобы при разных сбоях удержать данные, придумали идею составлять план (напоминает журналирование транзакций в базах данных) и по шагам выполнять план, по- степенно удаляя строчки выполненных шагов из журнала. Тогда при сбое можно будет вы- числить состояние, на котором случился сбой, и с него продолжить выполнять операции и тем самым завершить их успешно.

**Журналируемая файловая система** – файловая система, в которой осуществляется ведение журнала, хранящего список изменений, в той или иной степени помогающего сохра- нить целостность файловой системы при сбоях.

**3 типа журналов**:

> 1. Journal - в журнал помещаются и блоки данных и мета. (высокая надежность но мед- ленная работа)
2. Ordered Journal - записывeются только метаданные, то есть информация об изменениях файловой системы, после работы с каждым блоком
3. Writeback - записывeются только метаданные, то есть информация об изменениях фай- ловой системы, до работы с каждым блоком
> 

## 32. Обоснование необходимости и принципы построения распределенных ОС

Обоснования нобходимости распределенных ОС:

> 1. Производительность:
**Проблема**: упираемся в необходимоть повышении производительности
**Решение**: ставим больше процессоров Проблема: нагрузка на контроллер памяти
2. Надежность:
**Проблема**: выход из строя единственного сервера ведет к погибели всей системы
География:
**Проблема**: требуется поддержка запросов и откликов с любой точки мира
**Решение**: Пилим распределенную ОС
> 

Принципы построения распределённых ОС:

> 1. Ни один узел не имеет полной информации о состоянии всей системы
2. Узлы могут принимать решения только на основе локально имеющейся у них информации
3. Выход из строя какого-либо из узлов не должно приводить к отказу алгоритма управления
4. Не должно быть явного или неявного предположения о существовании глобаль- ных часов
> 

Прозрачность:

Прозрачность означает, что какие-то действия, события, состояния данные недоступны поль- зователю. Выделяют 4 вида прозрачности которые должны быть в распределенной ОС:

> 1. Прозрачность расположения - приложение не должно знать, где находится его ресурс
2. Прозрачность миграции - приложение не должно знать о перемещении ресурсов
3. Прозрачность размножения - приложение не должно знать о количестве копий ресурса
4. Прозрачность конкуренции - приложение не должно знать о конкуренции за ресурсы
> 

## 33. Алгоритмы управления памятью в распределенных ОС. Их преимущества и недостатки

1. Память с центральным сервером. Все разделяемые данные поддерживает центральный сервер.
    
    > + Простота в реализации алгоритма
    -  Сервер может стать узким местом
    > 
2. Миграция страниц. Страничный обмен с другим узлом в котором, рассполагается необходимая страница.
    
    > + Консистентность данных - данные существуют в одном экземпляре
    -  Trashing - два узла могут спорить за одну страницу и всё время перемещать её друг другу. ⇒ Частичное решение: timeout после перемещения страницы
    > 
3. Метод размножение для чтения. Страничное копирование с другим узлом в котором, расспо- лагается необходимая страница
    
    > + Производительность: возможность одновременного доступа по чтению
    -  Большой расход памяти: храним дубликаты одних и тех же данных на разных узлах
    -  Время: поиск данных.
    **Проблема**: может быть очень большой связный список.
    **Решение**: записать в список узы кому отдали страницу.
    **Проблема**: дополнительная нагрузка на узлы.
    ***Решение***: у каждого узла запрашивать о наличии страницы.
    -  Запись: противоречивые данные
    **Решение**: кидаем всем узлам сообщение убить страницу.
    **Проблема**: коллизия если два узла делают запись.
    > 
4. Метод полного размножение. Разрешим всем процессам вносить изменения и всем сообщать, что мы внесли изменения.
    
    > -  Модификации могут быть противоречивые
    **Решение**: сервер нумерации, который получает модификацию, присваивает но- мер странице и рассылает всем узлам
    > 

## 34. Методы управление файлами и каталогами в распре- деленных ОС. Их преимущества и недостатки

Методы управление файлами

1. Модель загрузки и разгрузки. 
Файл передается между клиентом (памятью или дисками) и сервером целиком
    
    > -  Не выгодные операции: перенести файлик 1 Гб ради изменения 1 бита
    > 
2. Модель удаленного доступа
    
    Происходит системный вызов на данные из файла в файловую систему. Отдаем узлу страницы которые нам нужны.
    
    > -  Сложность реализаци
    -  Тупики Методы управления каталогами
    > 
3. Узел + путь. Все узлы имеют какие-то имена: /hostname/root/... внутри узла
    
    > + Просто реализовать
    -  Нельзя иметь файлы из разных узлов в одном каталоге
    -  При перемещении файла нужно всем сообщать, что адрес поменялся
    > 
4. Монтирование. Каталог смонтирован так, что все узлы смонтированы в одно дерево в каждом узле.
    
    > + Легче отслеживать копирование и перемещение
    -  Может быть циклический граф при неаккуратном монтировании
    > 
5. Единое пространство имён. Единый каталог, который одинаково выглядит на всех узлах и любые действия синхронизируется в него. Можем построить графое БД или другое NoSQL решение
    
    > + Быстрый поиск
    -  Очень дорого, т.к нужно содержать БД
    > 

## 35. Синхронизация времени в распределенных системах. Метод Лампорта для синхронизации времени

Глобальные Часы:
На каждом сервере есть кварцевые часы, они достаточно точные, но за год, например, могут отстают на секунду.
**Проблема**: Процессы работают за микросекунды и отставание может вызвать сбой
**Частичное решение**: ставить на каждый сервер атомные часы Проблема: дорого
**Частичное решение**: синхронизировать Time Server’a
**Проблема**: сети не могут гарантировать одинаковую скорость доставки сообщения
 ⇒ глобальные часы не нужны

Метод Лампорта:
Синхронизация времени возможна, используя только логическое время. Важно не астро- номическое время, а только последовательность событий.
Событие A  $\xrightarrow{\text{предшествует}}$ событие  B = T  $\Longleftrightarrow$ если B - реакция на A, то А произошла до B 
истина когда:

- A и B произошли в пределах одного узла
- A - посылка из одного узла, а B - прием другим узлом

$t^n_i = t^n_{i-1} + \Delta t^n$ 

- $t'_i > t''_i \Rightarrow t''_{i+1} = t''_i + \Delta t''$
- $t’_i > t’’_i \Rightarrow t’’_{i+1} = t’’_i + \Delta t’’$
- $t’_i < t’’_i \Rightarrow$ Делаем перескок во времени на рассинхронизацию между углами $t’’_{i+1} = t’_i + \Delta t’$
- Чтобы $t ‘_i ≠ t’’_i$  для каждого узла добавляется уникальная дробная константа
    
    ![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image27.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image27.png)
    

## 36. Технологии виртуализации. Виды виртуализации: эму- ляция аппаратуры, полная виртуализация, паравирту- ализация, виртуализация уровня ядра операционной системы. Их достоинства и недостатки

**Технологии виртуализации** решают задачи распределения pool’a ресурсов между мно- жеством потребителей так, чтобы эти ресурсы были распределены по множеству узлов. Об- лачные решения основываются на технологиях виртуализации.

Изначальные основные задачи виртуализации:

> 1. Возможность поддержки устаревших ОС и приложений
2. Повышение отказаустойчивости и надежности
3. Созание средств для тестирования ПО
4. Консалидация серверов
5. Повышение управляемости и надежности сетевой инфраструктуры
> 

## Виды виртуализации

1. Эмуляция аппаратуры
А-ля наша машина и виртуалка с CentOS
    
    > + Нет ограничений в архитектуре
    > 
    > 
    > + Можем работать не модифицируя приложе- ние в GUEST OS
    > -  Производительность: приложение делает си- стемный вызов в HOST OS
    > -  Память: пересчёт памяти несколько раз
    > 
    
    ![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%2012.png)
    
2. Полная виртуализация
    
    HOST OS и GUEST OS c точки зрениия Hyper-visor’a находятся на одном уровне. 
    Hyper-visor - усеченная ОС, реализует распределение рессурсов (RR) между OS под его управлением работают.
    
    > + Нет ограничений для архитектуры
    + Можем работать не модифицируя приложе- ние в GUEST OS
    -  Потребность драйверов для Hyper-visor’a
    -  Архитектура HOST OS и GUEST OS должна быть совместима с архитектурой ап- паратного узла
    > 
    
    ![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%2013.png)
    
3. Паравиртуализация
    
    Наличие шины между GUEST OS, вместо драйверов 
    
    > + Нет ограничений в архитектуре 
    + Можем работать не модифицируя приложение в GUEST OS 
    + Производительность: более тесная интеграцию с гипервизором за счет шины
    -  Архитектура HOSTOS и GUESTOS должна быть совместима с архитектурой аппаратного узла
    > 
    
    ![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%2014.png)
    
4. Виртуализация уровня ядра (Контейнеризация)
    
    Виртуализация, при которой ядро является одним и тем же. Процессы внутри одного контейнера видят только друг друга и библиотеки
    
    > + Производительность: высокая эффективность использования аппаратных ресурсов
    -  Соместимость: контейнеры должны быть совместимы по ядру, т.е отсутвует возможность запуска на одном узле ОС разного типа (Windows и Linux)
    -  Безопастность: сбой на уровне ядра затронет все компоненты
    > 
    
    ![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%2015.png)
    

## 37. Архитектура облачных систем. Основные компоненты, их назначение и способы взаимодействия. Принципы мониторинга и управления производительностью в об- лачных системах

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image32.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image32.png)

**Проблема**: При переносе процесса с одного узла на другой потребуется полность пересоздать структуру процесса, причем с учетом специфики ОС другого узла

**Решение**: воспользоваться полной виртуализацией/паравиртуализацией

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%2016.png)

Можем спокойно переносить процессы вместе с адресным пространством с одного узла на другое 

**Проблема** : снижение производительности т.к адресное пространство в одном узле, а образ остался в исходном 
**Решение**: перенести образ системы 

**Проблема** : оооооччччень долгая передача, почти нереально 
**Решение**: добавить СХД (Система хранения данных)

![Untitled](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/Untitled%2017.png)

СХДобёртка под файловыми системами. Наружу представляется как диски, которые можно использовать и обращаться по сети – все виртуальные образы дисков можно туда перенести. Можно не переносить ничего, а просто говорить гипервизору, куда теперь обращаться. 

**Живая миграция** - перенос виртуальной машины с одного узла на другое без остановки приложений и без прерывания сессий прикладных протоколов. 

Для того чтобы корректно отслеживать ресурсы каждого узла и планировать переносы виртуальных машин добавляется аппаратный контролирующий узел

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image35.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image35.png)

Control Unit Имеет свое СУБД, в котором хранит все сведения о виртуальных машинах, хранит сведения по результатам мониторинга.

Способы опросов узлов:

> **1.** Night Calling - опрос каждого узла раз в ед. времени.
**Проблема**: нагрузка сети и трата ресурсов на сборку и отправку пакетов ("ну как там с памятью вопрос обстоит?")

**2.** Интеллектуальный Aгент - в каждую систему (хостовую и виртуальную) помещается агент, который собирает данные и сообщает о превышении выставленных поро- гов (изменяемых, в зависимости от ситуации). AMQP протокол - инфраструктура для работы с сообщениями и очередями.
> 

![tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image36.png](tickets-OS%20d9bfc98fee234907b5d06e224701ff6d/image36.png)