# lab-4. Perf tips

Цель: ознакомиться с инструментами и подходами, которые позволяют минимизировать аллокации памяти, расходы на GC. Написать решение, которое было бы оптимальным с точки зрения аллокаций и перфоманса.

## Подход к решению лабораторной работы

1. Ознакомьтесь с прикладной областью представленных вариантов, выберите какой-то из них.
2. Напишите минимальную реализацию поставленной задачи, опишите решение в первом пункте отчёта.
3. Соберите метрики: запустите бенчмарки тех частей алгоритмов, которые кажутся наиболее важными, сохраните результаты.
    
    Протестируйте реализацию в dotTrace и dotMemory, сохраните полученные результаты (лучше их как-то подписать, т.к. их будет много).
    
    Во второй пункт отчёта вставьте полученные результаты, а также дополните анализом: опишите проблемы, которые вы можете видеть на трейсах, предполагаемые причины и возможные фиксы.
    
4. Возьмите один из предложенных вариантов исправлений, которые были получены в пункте 3 и
    - реализуйте его,
    - соберите повторно метрики,
    - сравните.
5. Повторите действия из пункта 4. Результаты (как успешные, так и не очень), добавьте в третий пункт отчёта.

## Вариант 1. Генетический алгоритм

Требуется реализовать алгоритм, который по заданным ограничениям будет подбирать оптимальное решение задачи, используя подходы, построенные на генетических алгоритмах.

### Задание

Есть материальная точка, которая находится в точке (0, 0) на плоскости. Точка поддаётся законам механики (у точки есть скорость, а прикладывание силы создаёт ускорение); к ней каждые dt единиц времени прикладывается вектор силы, чтобы повлиять на траекторию движения.

Есть материальная точка, которая находится в точке (0, 0) на плоскости. В каждый момент времени точку можно сдвигать на определённый вектор. Требуется за минимальное количество движений переместиться в позицию (1, 1). При этом нельзя выходить за пределы квадрата.

Входные параменты:

- Максимальная длинна вектор, на которую можно точку сдвинуть за одну единицу времени.
- Пространство, в которое нельзя попадать точке, которое задаётся координатами центра и радиусом (т.е. круги, которые нужно обходить).

Пример конфигурационного файла:

```json
{
  "dt": 0.001,
  "Fmax": 1,
  "circles": [
    {
      "X": 0.33218833804130554,
      "Y": 0.15921106934547424,
      "R": 0.23818166553974152
    },
    {
      "X": 0.9211785793304443,
      "Y": 0.21001200377941132,
      "R": 0.24298787117004395
    },
    {
      "X": 0.6558014154434204,
      "Y": 0.7025460004806519,
      "R": 0.21127113699913025
    },
    {
      "X": 0.05513463541865349,
      "Y": 0.7919896245002747,
      "R": 0.20693418383598328
    }
  ]
}
```

### Теоретическая часть

Введём основные понятия:

- Ген — атомарный элемент генотипа и/или хромосомы.
- Хромосома — упорядоченный набор генов.
- Генотип — набор хромосом данной особи.
- Особи — хромосомы с закодированными в них параметрами задачи.
- Популяция — множество особей.

Идея генетических алгоритмов заключается в попытке найти решение для задач, где этот поиск очень сложен или невозможен.

В процессе решения через генетический алгоритм задачу сводят к генам, хромосомам и фитнес функциям. В контексте описанной выше задачи геном можно называть минимальную операцию, а именно применение определённого вектора силы на точку. Из векторов выстраивается список векторов, т.е. некоторая хромосома, которая и представляет собой решение задачи (i-ый ген — это сила, которая прикладывается в i-ый момент времени).

Фитнес функция — это метрика успешности особи. Если говорить про конкретную задачу планирования движения, то такой функцией можно считать количество применённых сил для достижения конца. Но также можно предположить, что далеко не все применения сил будут успешным доведением точки до конца, а значит можно подобрать фитнес функцию, которая поможет лучше добираться до конца.

На хромосому можно применить мутацию. Под мутацией подразумевается процесс создания копии хромосомы с изменёнными генами. Насколько изменёнными — вопрос реализации, но обычно подразумевается изменение одного гена.

Один из сложных вопросов при применении геналго — выбор начальной хромосомы. Самым простым способом может являться взятие рандомных значений или предположительно хорошего решения, которое нужно улучшить.

Более подробно можно изучить тему по книге “Рутковская. - Нейронные сети, генетические алгоритмы и нечеткие системы”.

### GUI

Воспринимать решение чуть проще, если есть визуализация. В организации появился репозиторий с шаблоном, в котором есть первые шаги, чтобы завести GUI. В темплейте есть проект с шаблоном на WPF, который не будет работать на маках. Для маководов можно попробовать взять темплейт с авалонией, она должна запускаться на маках.

## Вариант 2. Распределённая файловая система

Реализовать функционал распределённой файловой системы.

### Glossary

Распределённая файловая система — файловая система, которая может содержать распределённые ноды.

Нода — место хранения файлов, которое подключается к файловой системе и умеет обрабатывать запросы на добавление и удаление файлов. В рамках лабораторной работы подразумевается, что взаимодействие файловой системы с нодами будет происходить через TCP.

Относительный путь — это путь, который используется для размещения файла на ноде. Например, мы можем запросить у файловой системы разместить файл C:/file.txt на любой из нод с относительным путём /tmp/file.txt.

### Задание

Список поддерживаемых команд:

- /add-node <name> <ip> <size> — добавляет ноду.
- /add-file <path> <partial-path> — копирует указанный файл на файловую систему в одну из нод. Сохраняет по указанному относительному пути.
- /remove-file <path> — удаляет файл с ноды, на которой файл лежит.
- /exec <path> — выполнить команды, которые описаны в текстовом файле, путь к которому передаётся.
- /clean-node <name> — выгружает все файлы, которые находятся на указанной ноде, на другие ноды.
- /balance-node — перераспределяет файлы между нодами так, чтобы на всех нодах был максимально одинаковый процент нагрузки.

Для корректной работы нужно реализовать два вида запускаемых приложений: основной сервер и ноды. Ноды должны уметь обрабатывазать запросы от основного сервера. Основной сервер должен обрабатывать описанные выше команды. Формат общения между сервером и нодой остаются на усмотрение автора (здесь имеется в виду то, что будет использоваться во взаимодейтсвии поверх TCP: протоколы/спецификации/др.).

### Алгоритм работы для демонстрации

1. Запустить клиенты на трёх нодах, которые будут обрабатывать запросы от основного сервера. Можно запустить несколько нод на одной машине с разными TCP портами.
2. Написать файл с командами, который бы добавлял указанные три ноды, какое-то количество файлов разных размеров и выполнял ряд операций выгрузки, балансировки.
3. Запустить основной сервер и запустить выполнение команд из написанного файла.